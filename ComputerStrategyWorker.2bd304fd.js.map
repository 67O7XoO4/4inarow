{"version":3,"sources":["js/BoardModel.js","js/HumanGuiStrategy.js","js/HumanCliStrategy.js","js/ComputerStrategy.js","js/Player.js","js/MinMax.js","js/ComputerStrategyWorker.js"],"names":["EMPTY","color","name","defaultConfig","nbCellsToWin","nbRows","nbColumns","Cell","column","num","value","isWinning","Column","cells","Array","fill","map","v","i","isEmpty","find","cell","slice","reverse","foundCell","getLastPlayedCell","BoardModel","settings","Observable","Settings","init","onSizeChange","columns","$observable","emit","listen","array","players","rowNum","reduce","player","key","forEachCell","length","forEach","colNum","playedCells","toArray","data","cellNum","row","push","addListener","onPlay","checkIfLastPlayWin","pop","every","callback","colnum","play","isComplete","cellToTest","winningCells","getPrevious","_checkHorizontal","getLeftSibling","getRightSibling","getLeftPreviousSibling","getRightNextSibling","getLeftNextSibling","getRightPreviousSibling","left","right","nbLeft","apply","nbRight","mousePos","x","y","out","HumanGuiStrategy","board","isHuman","model","selectColumnFromPos","selectedColumn","getColumn","setSelectedColnum","Promise","resolve","reject","mousemove","evt","rect","canvas","getBoundingClientRect","clientX","clientY","top","addEventListener","mouseout","click","removeEventListeners","isInterrupted","removeEventListener","$clearAll","HumanCliStrategy","resolveCurrentPromise","selectColumn","currentPromise","finally","setSelectedColumn","columnNumber","interrupt","ComputerStrategy","depth","waiting","_currentPromiseResolve","worker","Worker","onerror","oEvent","console","log","postMessage","JSON","stringify","action","boardModel","playerToBeEvaluatedKey","currentPlayerKey","nextPlayer","onmessage","parse","Player","config","newval","$changeStrategy","timer","enable","timerEnabled","strategy","Timer","isCurrentPlayer","suspended","Object","assign","remoteManager","HumanRemoteStrategy","level","isRemote","resume","suspend","otherPlayer","reset","error","MAX_SCORE","CANT_PLAY_SCORE","DRAW_SCORE","EMTPY_CELL_SCORE","SAME_PLAYER_CELL_SCORE","cachedScores","pickColumn","playerToBeEvaluated","interruptable","selection","minMax","currentPlayer","currentDepth","firstRecursion","initialScore","currentPlayerCoeff","score","evaluate","minOrMax","columnScore","currenScore","headsOrTails","scoreKey","currentSelection","removeLastPlay","Math","floor","random","total","lastPlayedCell","getFirstCell","evaluateCell","evaluateDirection","getNext","getConfig","actions","initPlayer","MinMax"],"mappings":"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","file":"ComputerStrategyWorker.2bd304fd.js","sourceRoot":"..","sourcesContent":["\nimport * as Settings from './util/Settings.js';\nimport * as Observable from './util/Observable.js';\n\n//Empty cell\nconst EMPTY = { color : \"\", name : '-'};\n\n// default config if no settings are provided\nconst defaultConfig = {\n    nbCellsToWin: 4,\n    nbRows      : 6,\n    nbColumns   : 7,\n};\n\nclass Cell {\n    constructor(column, num){\n        this.num = num;\n        this.column = column;\n\n        this.value = EMPTY;\n        this.isWinning = false;\n    }\n\n    isEmpty(){\n        return this.value === EMPTY;\n    }\n}\n\nclass Column {\n    constructor(num, nbRows){\n        this.num = num;\n        //fill column with nbRows cells\n        this.cells = Array(nbRows).fill().map((v,i)=>(new Cell(this, i)));\n    }\n\n    isEmpty(){\n        return  this.cells[0].isEmpty();\n    }\n\n    isComplete(){\n        return  ! this.cells.find((cell)=> cell.isEmpty() );\n    }\n\n    getLastPlayedCell(){\n        return  this.cells\n                        .slice()\n                        .reverse()\n                        .find((cell)=> ! cell.isEmpty() );\n    }\n    \n    getFirstCell(){\n        return  this.cells[0];\n    }\n\n    removeLastPlay(){\n        let foundCell = this.getLastPlayedCell();\n        if (foundCell){\n            foundCell.value = EMPTY;\n        }\n    }\n}\n\nclass BoardModel {\n    columns = null;\n    playedCells = [];\n    $observable = new Observable.Observable();\n\n    constructor(settings = defaultConfig){\n        this.settings = Settings.init(settings);\n\n        let onSizeChange = ()=>{\n            //fill board with columns\n            this.columns = Array(this.settings.nbColumns)\n                            .fill()\n                            .map((v,i)=>(new Column(i, this.settings.nbRows)));\n            \n            this.$observable.emit('onSizeChange');\n        };\n\n        this.settings.listen('nbColumns', onSizeChange);\n        this.settings.listen('nbRows', onSizeChange);\n\n        onSizeChange();\n    }\n\n    /**\n     * useful for unit test or to unserialize the boardmodel\n     * \n     * initialize the board with the given array\n     * awaited format example (only the first 3 rows are described, the left ones are still empty):\n     * [\n     * [0, player1, player1, 0, 0,      0, 0],\n     * [0, player1, player2, 0, 0,      0, 0],\n     * [0, player1, player2, 0, 0, player2, 0]\n     * ]\n     * \n     * @param {*} array [[]] \n     * @param players optionnal - array of the real player object. Must be found by their key in th array\n     */\n    init(array, players){\n        let rowNum = 0;\n\n        if (players){\n            players = players.reduce(function(map, player) {\n                map[player.key] = player;\n                return map;\n            }, {});\n        }\n\n        //empty the board\n        this.forEachCell((column, cell)=>{\n            this.columns[column.num].cells[cell.num].value = EMPTY;\n            this.columns[column.num].cells[cell.num].isWinning = false;\n        });\n\n        //forEach Right\n        for(let i=array.length-1; i>=0; i--){\n\n            array[i].forEach((value, colNum)=>{\n\n                if ( value) {\n                    if (players){\n                        value = players[value] ;\n                    }\n                    this.columns[colNum].cells[rowNum].value = value;\n                }\n            })\n            rowNum++;\n        }\n        this.playedCells = [];\n    }\n\n    /**\n     * serialize board data:\n     * {\n     *  settings : array of settings,\n     *  data : array of rows with the key of the value and 0 when empty\n     *          awaited format by the init() function above\n     * }\n     */\n    toArray(){\n        return { \n            settings : this.settings.toArray(),\n            data : Array(this.settings.nbRows).fill().map((v,cellNum)=>{\n                let row = [];\n\n                this.columns.forEach(column=>{\n                    let value = column.cells[cellNum].value;\n                    if ( value === EMPTY) {\n                        value = 0;\n                    }else{\n                        value = value.key;\n                    }\n                    row.push(value);\n                });\n                return row;\n        }).reverse() };\n    }\n    \n    onSizeChange(onSizeChange){\n        return this.$observable.addListener('onSizeChange', onSizeChange);\n    }\n\n    onPlay(onPlay){\n        return this.$observable.addListener('onPlay', onPlay);\n    }\n\n    clearAll(){\n        this.init([[]]);\n    }\n\n    key(){\n        let key = \"\";\n        this.forEachCell((column, cell)=>{\n            key += cell.value.name;\n        });\n        return key;\n    }\n\n    getLastPlayedCell(){\n        if(this.playedCells.length == 0) return null;\n        return  this.playedCells[this.playedCells.length - 1];\n    }\n\n    undoLastMove(){\n\n        let isWinning = this.checkIfLastPlayWin();\n        let cell = this.playedCells.pop();\n        cell.value = EMPTY;\n\n        if (isWinning){\n            this.forEachCell((column, cell)=>{\n                this.columns[column.num].cells[cell.num].isWinning = false;\n            });    \n            return true;\n        }\n\n\n        return false;\n    }\n\n    isEmpty(){\n        return  this.columns.every((column)=>{\n            return column.isEmpty();\n        });\n    }\n\n    /**\n     * \n     * @param {*} callback(column, cell)\n     */    \n    forEachCell(callback){\n        this.columns.forEach((column)=>{\n            column.cells.forEach((cell)=>callback(column, cell))\n        });\n    }\n\n    /**\n     * \n     * @param {*} player \n     */\n    playAtSelectedColumn(colnum, player){\n        this.play(this.columns[colnum], player);\n    }\n    \n    /**\n     * \n     * @param {*} column \n     * @param {*} player \n     */\n    play(column, player){\n        let foundCell = column.cells.find((cell)=> cell.isEmpty() );\n        if (foundCell) {\n            foundCell.value = player;\n        }else{\n            throw \"Can't play on complete column : \"+column.num;\n        }\n        this.playedCells.push(foundCell);\n\n        this.$observable.emit('onPlay', column, player);\n    }\n\n    isComplete(){\n        return this.columns.every((column)=> column.isComplete());\n    }\n\n    /**\n     * \n     */\n    checkIfLastPlayWin(){\n        // vertical\n        let i=0;\n        let cellToTest = this.getLastPlayedCell();\n        let winningCells = [];\n\n        if (! cellToTest) {\n            return false;\n        }\n        \n        for(; i < this.settings.nbCellsToWin; i++){\n            if (!cellToTest || cellToTest.value != this.getLastPlayedCell().value){\n                break;\n            }\n            winningCells.push(cellToTest);  \n            cellToTest = this.getPrevious(cellToTest);\n        }\n        if (i == this.settings.nbCellsToWin){\n            winningCells.forEach(cell=>cell.isWinning = true);\n            return true;\n        }\n        \n        //horizontal\n        if (this._checkHorizontal(this.getLastPlayedCell(), this.getLeftSibling, this.getRightSibling)){\n            return true;\n        }\n        //diag bottom to up\n        if (this._checkHorizontal(this.getLastPlayedCell(), this.getLeftPreviousSibling, this.getRightNextSibling)){\n            return true;\n        }\n\n        //diag up to bottom\n        if (this._checkHorizontal(this.getLastPlayedCell(), this.getLeftNextSibling, this.getRightPreviousSibling)){\n            return true;\n        }\n        return false;\n    }\n\n    //\n    _checkHorizontal(cell, left, right){\n        let winningCells = [];\n        \n        //check if there is at most 'nbCellsToWin' cells on the left side of the cell\n        let nbLeft=0;\n        var cellToTest = left.apply(this, [cell]);\n        if (cellToTest){\n            \n            for(; nbLeft < this.settings.nbCellsToWin-1; nbLeft++){\n                if (!cellToTest || cellToTest.value != cell.value){\n                    break;\n                }\n                winningCells.push(cellToTest);\n                cellToTest = left.apply(this, [cellToTest]);\n            }\n        }\n\n        //same thing on the right side\n        let nbRight=0;\n        cellToTest = right.apply(this, [cell]);\n        if (cellToTest){\n            for(; nbRight < this.settings.nbCellsToWin-1; nbRight++){\n                if (!cellToTest || cellToTest.value != cell.value){\n                    break;\n                }\n                winningCells.push(cellToTest);\n                cellToTest = right.apply(this, [cellToTest]);\n            }\n        }\n\n        //\n        let isWinning = (nbRight + nbLeft + 1 >= this.settings.nbCellsToWin);\n\n        if (isWinning){\n            winningCells.push(cell);\n            winningCells.forEach(cell=>cell.isWinning = true);\n        }\n        \n        return isWinning;\n    }\n\n    getPrevious(cell){\n        if (cell.num == 0) return null;\n        return cell.column.cells[cell.num -1];\n    }\n\n    getNext(cell){\n        if (cell.num + 1 == this.settings.nbRows ) return null;\n        return cell.column.cells[cell.num +1];\n    }\n\n    getLeftSibling(cell){\n        if (cell.column.num == 0) return null;\n        return  this.columns[cell.column.num -1].cells[cell.num];\n    }\n\n    getRightSibling(cell){\n        if (cell.column.num + 1 == this.settings.nbColumns ) return null;\n        return  this.columns[cell.column.num +1].cells[cell.num];\n    }\n    \n    getLeftPreviousSibling(cell){\n        if (cell.column.num == 0 || cell.num == 0) return null;\n        return  this.columns[cell.column.num -1].cells[cell.num-1];\n    }\n\n    getRightPreviousSibling(cell){\n        if (cell.column.num + 1 == this.settings.nbColumns || cell.num == 0) return null;\n        return  this.columns[cell.column.num +1].cells[cell.num-1];\n    }\n\n    getLeftNextSibling(cell){\n        if (cell.column.num == 0 || cell.num+1 == this.settings.nbRows) return null;\n        return  this.columns[cell.column.num -1].cells[cell.num+1];\n    }\n\n    getRightNextSibling(cell){\n        if (cell.column.num + 1 == this.settings.nbColumns || cell.num+1 == this.settings.nbRows) return null;\n        return  this.columns[cell.column.num +1].cells[cell.num+1];\n    }\n\n    getConfig(){\n        return this.settings;\n    }\n}\n\nexport { BoardModel };\n","\n\nlet mousePos = {x: 0, y:0, out: true}; //out = mouse over or not\n\n/**\n * Human strategy when a GUI is available \n */\nclass HumanGuiStrategy  {\n\n    constructor(board){\n        this.isHuman = true;\n        this.board = board;\n    }\n\n\n    selectColumn(model){\n    \n        let selectColumnFromPos = function(board, x){\n            let selectedColumn = board.getColumn(x);\n            if ( selectedColumn && ! selectedColumn.isComplete()){\n                board.setSelectedColnum(selectedColumn.num);\n            }else{\n                selectedColumn = null;\n            }\n            return selectedColumn;\n        }\n\n        return new Promise((resolve, reject)=>{\n\n            //reset the selected column to the current mouse position\n            let selectedColumn = selectColumnFromPos(this.board, mousePos.x);\n\n            //listen to mouse event, find the selected column and play\n\n            let mousemove = (evt)=>{\n                var rect =  this.board.canvas.getBoundingClientRect();\n        \n                mousePos.out = false;\n        \n                mousePos.x = evt.clientX - rect.left;\n                mousePos.y = evt.clientY - rect.top;\n        \n                selectedColumn = selectColumnFromPos(this.board, mousePos.x);\n                //console.debug(mousePos);\n            };\n            this.board.canvas.addEventListener('mousemove', mousemove, false);\n            let mouseout =  ()=> (mousePos.out = true);\n            this.board.canvas.addEventListener('mouseout', mouseout, false);\n            let click = ()=> {\n                if (selectedColumn != null){\n\n                    //current player has played, let's clean the listener and resolve the promise \n                    removeEventListeners(false);\n                }\n            };\n            this.board.canvas.addEventListener('click', click, false);\n\n            let removeEventListeners = (isInterrupted)=>{\n                this.board.canvas.removeEventListener('mousemove', mousemove, false);\n                this.board.canvas.removeEventListener('mouseout', mouseout, false);\n                this.board.canvas.removeEventListener('click', click, false);\n\n                 this.$clearAll = null;\n\n                if(isInterrupted){\n                    resolve(null);\n                }else{\n                    resolve(selectedColumn.num);\n                }\n            };\n            this.$clearAll = removeEventListeners;\n        });\n    } \n\n    /**\n     * \n     */\n    interrupt(){\n        //we have been interrupted, we clean the listener (if exist) and abort (reject) the play\n        if (this.$clearAll) this.$clearAll(true);\n    }\n};\n\nexport {HumanGuiStrategy as HumanGuiStrategy};","\n\n\n/**\n * Human Strategy when no GUI board are available\n * useful for CLI interface or unit test\n */\nclass HumanCliStrategy  {\n\n    constructor(){\n        this.isHuman = true;\n        \n        let resolveCurrentPromise = null;\n     \n        this.selectColumn = function(model){\n\n            let currentPromise = new Promise((resolve, reject)=>{\n                resolveCurrentPromise = resolve; \n            });\n        \n            //clear promise when fullfilled\n            currentPromise.finally(()=>{\n                resolveCurrentPromise = null;\n            })\n\n            return currentPromise;\n        } \n\n        /**\n         * just set the column to be played with setSelectedColumn() function\n         * \n         * @param {*} columnNumber \n         */\n        this.setSelectedColumn = function(columnNumber){\n            resolveCurrentPromise(columnNumber);\n        }\n\n        /**\n         * \n         */\n        this.interrupt = function(){\n            if (resolveCurrentPromise) {\n                resolveCurrentPromise();\n            }\n        }\n    }\n};\n\nexport {HumanCliStrategy};","\nclass ComputerStrategy  {\n\n    /**\n     * \n     */\n    depth = 5 ; \n \n    constructor(player, depth){\n        \n        this.waiting = false;\n        \n        this.isHuman = false;\n        this.player = player;\n        this.depth = depth;\n        \n        this._currentPromiseResolve = null;\n    }\n\n    /**\n     * \n     * @param {*} model \n     */\n    selectColumn(model){\n        \n        this.waiting = true;\n        \n        return new Promise((resolve) => {\n\n            this._currentPromiseResolve = resolve; \n\n            if (this.worker== null){\n                //console.log('typeof Worker' , Worker);\n                // if ( ! window && !! window.Worker){\n                //     var Worker = require(\"tiny-worker\");//webWorker for node.js useful for unit test with jasmine\n                //     worker = new Worker(\"../../../js/ComputerStrategyWorker.js\",[], {esm: true});\n                // }else{\n                    this.worker = new Worker(\"ComputerStrategyWorker.js\");\n                // }\n            }\n                    \n            this.worker.onerror = function(oEvent) {\n                console.log('Worker on error : ', oEvent);\n\n                this.waiting = false;\n                resolve(null); //TODO \n            };\n\n            //run MinMax\n            this.worker.postMessage(JSON.stringify({\n                action : 'runMinMax',\n                boardModel: model.toArray(),\n                playerToBeEvaluatedKey: this.player.key,\n                currentPlayerKey : this.player.nextPlayer.key,\n                depth : this.depth,\n            }));\n\n            //receive MinMax result\n            this.worker.onmessage = function(oEvent) {\n                //console.log('Worker said : ', oEvent);\n                let data = JSON.parse(oEvent.data);\n                this.waiting = false;\n                resolve(data.colnum);\n            };\n            \n        });\n    };\n\n    /**\n     */\n    interrupt(){\n        if (this.worker){\n            this.worker.postMessage(JSON.stringify({\n                action : 'interrupt'\n            }));    \n        }\n    }\n}\n\nexport {\n    ComputerStrategy\n};\n","\nimport * as HumanGuiStrategy from './HumanGuiStrategy.js';\nimport * as HumanCliStrategy from './HumanCliStrategy.js';\nimport * as ComputerStrategy from './ComputerStrategy.js'; \nimport * as HumanRemoteStrategy from './HumanRemoteStrategy.js';\n\nimport * as Timer from './util/Timer.js';\nimport * as Settings from './util/Settings.js';\n\n/**\n * Player can be a human or a computer type\n * Its strategy will be updated according its type\n * \n * a Strategy must looks like:\n *  {\n *      isHuman\n *      Promise selectColumn(model) //the promise is resolved when the player choose a column. The promise return the choosen column number\n *      interrupt()\n *  }\n * \n */\nclass Player {\n    \n    /**\n     * \n     * @param {*} config if a String then it will be the name of the player else\n     * {\n     *      key :''         // to identify the player\n     *      name : ''       // name of the player\n     *      color : ''      // color of the player\n     * }\n     * @param {*} settings : isHuman, level\n     */\n    constructor(config, settings){\n        \n        this.settings = Settings.init(settings);\n\n        let isHuman = this.settings.listen('isHuman', (newval)=>{\n            this.$changeStrategy(newval);\n            this.timer.enable(config.timerEnabled && newval);\n        }, false);\n\n        this.settings.listen('level', (newval)=>{\n            this.strategy.depth = newval;\n        }, 3);\n\n        this.timer = new Timer.Timer(config.timerEnabled && isHuman);\n        this.nextPlayer = null;\n        this.isCurrentPlayer = false;\n        //color\n\n        this.suspended = false;\n\n        this.$changeStrategy(isHuman);\n\n        if (typeof config == \"string\"){\n            this.name = config;\n            this.key = config;\n        }else{\n            Object.assign(this, config);\n        }\n    }\n\n\n    $changeStrategy(isHuman){\n        if ( isHuman ){\n            if (this.remoteManager){\n                this.strategy = new HumanRemoteStrategy.HumanRemoteStrategy();\n            }else if (this.board){\n                this.strategy = new HumanGuiStrategy.HumanGuiStrategy(this.board);\n            }else{\n                this.strategy = new HumanCliStrategy.HumanCliStrategy();\n            }\n        }else{\n            this.strategy = new ComputerStrategy.ComputerStrategy(this, this.settings.level);\n        }\n    }\n\n    isHuman(){\n        return this.strategy.isHuman;\n    }\n\n    isRemote(){\n        return this.strategy.isRemote;\n    }\n\n    /**human need a board to play with a GUI */\n    setBoard(board){\n        this.board = board;\n        //update strategy with the new board\n        this.$changeStrategy(this.isHuman());\n    }\n\n    /**\n     * Set the player as remote.\n     * \n     * @param {*} remoteManager used to communicate with the remote player. if null the player will be local\n     */\n    setRemote(remoteManager, model){\n        if (this.remoteManager != remoteManager){\n            this.remoteManager = remoteManager;\n            this.$changeStrategy(true);\n            if (remoteManager) this.strategy.init(remoteManager, model);\n        }\n    }\n\n\n    /**\n     * Call by the app when the player is the current player and should play\n     * \n     * @param {*} model \n     * @returns a Promise with the choosen column number \n     */\n    selectColumn(model){\n        this.timer.resume();\n        return this.strategy.selectColumn(model)\n        .finally(()=>{\n            this.timer.suspend();\n        });\n    } \n\n    /**\n     * this player become the curent player and 'otherPlayer' will be the next\n     * initialize players in order to both players to know who is the next one\n     * @param {*} otherPlayer \n     */\n    initPlayer(otherPlayer){\n        this.nextPlayer = otherPlayer;\n        otherPlayer.nextPlayer = this;\n\n        this.isCurrentPlayer = true;\n        otherPlayer.isCurrentPlayer = false;\n\n        this.timer.reset();\n        otherPlayer.timer.reset();\n    }\n\n    /**\n     * \n     */\n    switchToNextPlayer(){\n        if (! this.isCurrentPlayer) console.error(\"The player\", this.name, \"is not the current one. switchToNextPlayer() must not be called\")\n        this.isCurrentPlayer = false;\n        this.nextPlayer.isCurrentPlayer = true;\n        \n        return this.nextPlayer;\n    }\n\n    /** interrupt a player while playing \n    */\n    interrupt(){\n       this.strategy.interrupt();\n    }\n};\n\nexport {Player};","const MAX_SCORE = 1000;\n\nconst CANT_PLAY_SCORE = MAX_SCORE + 1;\n\nconst DRAW_SCORE = 0;\nconst EMTPY_CELL_SCORE = 1;\nconst SAME_PLAYER_CELL_SCORE = 5;\n\nlet cachedScores = [];\n\n/**\n * Run the min-max algorithm to find the best column to play on the given board model.\n * \n * @param {*} model \n * @param depth\n */\nfunction pickColumn(model, playerToBeEvaluated, depth, interruptable){\n    cachedScores = [];\n    let selection = minMax( model, playerToBeEvaluated, playerToBeEvaluated.nextPlayer, depth, interruptable, true);\n    \n    return selection.num;\n}\n\n\n\n/**\n * https://fr.wikipedia.org/wiki/Algorithme_minimax\n * \n * @param {*} model \n * @param playerToBeEvaluated\n * @param {*} currentPlayer player who just played\n * \n * @returns {score: columnScore, num : column.num}\n */\nfunction minMax(model, playerToBeEvaluated, currentPlayer, currentDepth, interruptable, firstRecursion){\n\n    let initialScore = null;\n    let currentPlayerCoeff = (currentPlayer === playerToBeEvaluated ? 1 : -1);\n\n\n    if (interruptable && interruptable.isInterrupted()){\n        return {\n            score: DRAW_SCORE , \n            num : null\n        };\n    }\n    //evaluation of the last move (of the current player)\n    \n    //is last move a win ?\n    if (model.getLastPlayedCell() && model.checkIfLastPlayWin()){\n        return {\n                score: MAX_SCORE * currentPlayerCoeff, \n                num : model.getLastPlayedCell().column.num\n            };\n\n    }else if (model.isComplete()){\n        //draw game\n        return {\n            score: DRAW_SCORE , \n            num : model.getLastPlayedCell().column.num\n        };\n\n    }else  if(currentDepth === 0 ){\n        // evaluate the state of the game for the current Player\n        return {\n            score: evaluate(model, currentPlayer) * currentPlayerCoeff ,\n            num : model.getLastPlayedCell().column.num\n        };\n\n    } else {\n\n        let minOrMax = null; //min or max method to be called\n\n        if (playerToBeEvaluated === currentPlayer.nextPlayer){\n            //maximize the score\n            initialScore = - CANT_PLAY_SCORE;\n            minOrMax = (columnScore, currenScore)=>{\n                if (columnScore == currenScore)\n                    return headsOrTails();\n                return columnScore > currenScore\n            };\n    \n        }else {\n            //minimizing score \n            initialScore = CANT_PLAY_SCORE;\n            minOrMax = (columnScore, currenScore)=>{\n                if (columnScore == currenScore)\n                    return headsOrTails();\n                return columnScore < currenScore\n            };\n        }\n\n        let scoreKey = model.key()+currentPlayer.key;\n        let score = cachedScores[scoreKey];\n        if ( ! score){\n            //go deeper\n            score =  model.columns.reduce((currentSelection, column)=>{\n\n                let columnScore=null;\n\n                if(! column.isComplete()){\n                    //the next player plays and become the current player\n                    model.play(column, currentPlayer.nextPlayer);\n                    columnScore = minMax(model, playerToBeEvaluated, currentPlayer.nextPlayer, currentDepth - 1, false).score;\n                    column.removeLastPlay();\n                \n                }else{\n                    //don't play on complete column\n                    columnScore = initialScore;\n                }\n                \n                 if (firstRecursion)\n                    console.log('minMax:', column.num,\"=\" ,columnScore);\n                \n                return  minOrMax(columnScore, currentSelection.score) ? \n                            {score: columnScore, num : column.num} : currentSelection;\n\n            }, {score: initialScore, num : 0});//initial selection\n\n            cachedScores[scoreKey] = score;\n        }\n        return score;\n    }\n};\n\nfunction headsOrTails() {\n    return Math.floor(Math.random() * Math.floor(2));\n}\n\n/**\n * \n * @param {*} model \n * @param {*} playerToBeEvaluated \n */\nfunction evaluate(model, playerToBeEvaluated){\n    \n    let total = model.columns.reduce((score, column) => {\n        \n        let lastPlayedCell = column.getLastPlayedCell();\n        //if there is no last played cell, we take the first (empty) cell to evaluate\n        if (! lastPlayedCell ) lastPlayedCell = column.getFirstCell();\n\n        let cellScore = evaluateCell(lastPlayedCell, model, playerToBeEvaluated) ;\n\n        return  score += cellScore  ;\n\n    }, 0);\n    \n\n    return total;\n}\n\n/**\n * \n */\nfunction evaluateCell(cell, model, playerToBeEvaluated){ \n\n    let score=0;\n\n    if (cell.value === playerToBeEvaluated || cell.isEmpty() ){\n        //vertical\n        score += evaluateDirection(cell, model, playerToBeEvaluated, model.getPrevious, model.getNext);\n        //horizontal\n        score += evaluateDirection(cell, model, playerToBeEvaluated, model.getLeftSibling, model.getRightSibling);\n        //diag bottom to up\n        score += evaluateDirection(cell, model, playerToBeEvaluated, model.getLeftPreviousSibling, model.getRightNextSibling);\n        //diag up to bottom\n        score += evaluateDirection(cell, model, playerToBeEvaluated, model.getLeftNextSibling, model.getRightPreviousSibling);\n        \n        //add bonus if the current cell is owned by the player to be evaluated \n        // and there is a chance to have a winning position (score>0) \n        if (score > 0 && cell.value === playerToBeEvaluated){\n            score += SAME_PLAYER_CELL_SCORE;\n        }\n    }\n\n    //console.log(score);\n\n    return score;\n}\n\n//\nfunction evaluateDirection(cell, model, playerToBeEvaluated, left, right){\n    let score=0;\n\n    //check if there is at most 'nbCellsToWin' cells on the left side of the cell\n    let nbLeft=0;\n    let cellToTest = left.apply(model, [cell]);\n    if (cellToTest){\n        \n        for(; nbLeft < model.getConfig().nbCellsToWin-1; nbLeft++){\n            if (!cellToTest){\n                //border of the board\n                break;\n\n            }else if (cellToTest.isEmpty() ){\n                score += EMTPY_CELL_SCORE;\n\n            } else if (cellToTest.value === playerToBeEvaluated){\n                score += SAME_PLAYER_CELL_SCORE;\n\n            }else{\n                //cell of the other player, we stop here\n                break;\n            }\n            cellToTest = left.apply(model, [cellToTest]);\n        }\n    }\n\n    //same thing on the right side\n    let nbRight=0;\n    cellToTest = right.apply(model, [cell]);\n    if (cellToTest){\n        for(; nbRight < model.getConfig().nbCellsToWin-1; nbRight++){\n            if (!cellToTest){\n                break;\n\n            }else if (cellToTest.isEmpty() ){\n                score += EMTPY_CELL_SCORE;\n\n            } else if (cellToTest.value === playerToBeEvaluated){\n                score += SAME_PLAYER_CELL_SCORE;\n                \n            }else{\n                //cell of the other player, we stop here\n                break;\n            }\n            cellToTest = right.apply(model, [cellToTest]);\n        }\n    }\n    if ( (nbRight + nbLeft + 1) < model.getConfig().nbCellsToWin ){\n        //reset score if there no chance to get enough cells to win\n        score = 0;\n    }\n    return score;\n}\n\n\nexport {\n    pickColumn,\n    //for unit testing only\n    evaluate,\n    evaluateCell, \n    MAX_SCORE,\n    DRAW_SCORE,\n    EMTPY_CELL_SCORE,\n    SAME_PLAYER_CELL_SCORE\n};\n","import { BoardModel } from \"./BoardModel\";\nimport { Player } from \"./Player\";\nimport * as MinMax from \"./MinMax\";\n\nlet isInterrupted  = false;\nlet actions={};\n\n//message received from ComputerStrategy\nonmessage = function(oEvent) {\n    let data = JSON.parse(oEvent.data)\n    //console.log('from main thread : ', data);\n    //run the required action\n    actions[data.action].apply(null, [data]);\n};\n\nactions['interrupt'] = function(data){\n    isInterrupted  = true;\n};\n\n// run mimax action\nactions['runMinMax'] = function(data){\n    isInterrupted  = false;\n    // recreate the Two users\n    let playerToBeEvaluated = new Player(data.playerToBeEvaluatedKey);\n    let currentPlayer = new Player(data.currentPlayerKey);\n\n    currentPlayer.initPlayer(playerToBeEvaluated);\n\n    //recreate the boardmodel \n    let board = new BoardModel(data.boardModel.settings);\n    board.init(data.boardModel.data, [currentPlayer, playerToBeEvaluated]);\n\n    //run minmax\n    let colnum = MinMax.pickColumn(board, playerToBeEvaluated,  data.depth, {isInterrupted : function(){return isInterrupted;} });\n    \n    //post result\n    postMessage(JSON.stringify({\n        colnum : colnum\n    }));\n};\n"]}